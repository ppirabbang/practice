- list_int = list(map(int,sys.stdin.readline().split()) 이 입력한 숫자들 배열에 넣는 방법
- b = "abc" 에서 b[0] b[1] b[2] 와 같이 인덱싱 가능, 끝 자리는 b[-1] 도 되는데 개행문자가 들어가니까 rstrip() 써주면 됨
- import sys
  N = int(sys.stdin.readline().rstrip()) 이 입력이 더 빠름, rstrip() 은 자동으로 붙는 개행문자 제거
- print("long", end="") 식으로 하면 반복문도 한 줄로 출력 가능, 반복문 밖에서 print 해도 한 줄로 출력됨
- 최대 최소 문제 maximum = max(list_int) minimum = min(list_int) 와 같이 함수 쓸 생각해야 됨
- 파이썬은 temp 두고 바꿀 필요 없이  a,b = b,a 가능함,, a[0] = a[2] 와 같이 바꾸는건 안됨(immuatable), 그래서 문자열을 뒤집으려면 a = a[::-1] 로 해야됨
- print(len(sys.stdin.readline())) 을 하면 당연히 문자열 마지막 \0 도 포함 되므로 -1 을 해줘야 함
- ord() : (A -> 65) 
  chr() : (65 -> A)
- find() 는 처음 나오는 위치를 반환함, 이후에 나오는 걸 찾으려면 first = text.find('a') second = text.find('a', first + 1) 로 해야됨
- groups = ["ABC","DEF","GHI","JKL","MNO","PQRS","TUV","WXYZ"] ,,, for index,value in enumerate(groups): 하면 index 에는 인덱스 value에는 배열 원소가 들어감
- dict_int = {value:index for index,value in enumerate(배열배열)
- for i in list_int: # i가 인덱스가 아님 list_int에 들어간 원소를 가리킴
- max_index = list_int.index(maximum)
  #list.index(값) 함수는 리스트를 0번부터 훑으면서, 괄호 안의 '값'과 똑같은 값이 발견되면 그 즉시 그 자리가 몇 번째 칸(인덱스)인지 알려주고 끝납니다.
- 중복되는 문자열을 찾을 때(2941번) 간단한 특수 문자나 알아볼 수 있는 문자로 변환하는 아이디어 
- ex) 문자가 연속으로 나오거나 연속이 아니라면 문자열 안에서 한 번만 나와야 한다 --> unique 와 같이 어려운 생각 하지 말고 일단
- 문자가 연속으로 나온다 -> 다음 인덱스 문자가 같은 경우는 상관 없고 다르다면 -> 문자열 안에서 한 번만 나와야 한다 -> 해당 인덱스 이후부터 끝까지 찾기 -> word[j] in word[j+1:]  
- 소수점 몇 째 자리까지 --> print("%.6f", 계산식~!) 과 같이 표현, 25206 최적화 코드 참고
- [[0] * cols for i in range(rows)] 2차원 배열 선언 방법
- 중복된 걸 1개로 처리해주는 set() 함수를 사용해서 겹치는 부분의 넓이 등에 활용하면 좋을 듯, paper = set() paper.add(x좌표,y좌표) 하면 알아서 겹치는건 1개로 처리해준다 이후 길이를 반환하면 넓이와 동일하다
- numbers = [1, 2, 3]
  1. map(str, numbers) -> 숫자들을 전부 문자로 변환 ('1', '2', '3')
  2. 그 다음 join으로 연결
  result = " + ".join(map(str, numbers))
  print(result)
  결과: 1 + 2 + 3
- 정수 좌표 구할 때 xor 연산을 사용하면 입력이 같다면 0, 다르면 입력값이 저장되므로 활용할 수 있을 듯
- 삼각형 둘레의 최대합은 가장 긴 변이 나머지 두 변의 합 * 2 - 1 이면 된다
- 인덱스 i가 j 보다 작아야 된다 등등을 생각할 때는 if로 조건을 걸거나 끝을 다르게 해줘도 방법이 있겠지만 아예 시작을 겹치지 않게 하면 된다 ex) 중첩 for 문 상황에서 두 번째 중첩에서 시작을 j = i + 1 과 같이 하면 겹치지 않는다
- 빈 리스트를 선언하고 append 를 하는 경우 메모리 재할당이 for 문 반복 횟수만큼 일어나기 때문에 메모리 초과가 일어날 수 있음. 10989번 참고
- sort() 로 좌표 정리하면 알아서 x 순으로 정리하고 같다면 y 순으로 정리함
- sort(key=lambda x : (x[1],x[0])) 이면 x 가 sort 진행 중인 배열의 한 원소를 가리키고 기준을 y좌표,x좌표로 잡으라는 것. 이러면 y 좌표가 동일할 때 x 좌표 크기에 맞게 정렬됨, x[0] 선언을 안하면 y좌표만 기준으로 잡기 때문에 y좌표가 같다면 입력 순서 그대로 놔둠. x[1] 이 첫 번째 정렬 기준이고, x[1]로 정렬이 안된다면 x[0]에 맞게 정렬한다는 것.
- 중복 입력이 있는데 중복을 지우고 싶으면 list_set = set(입력입력) 으로 받고 list_string  = list(list_set) 으로 바꿔주자
- sort 는 원본을 정렬, sorted 는 원본 정렬한 새로운 배열 생성, 둘 다 key 설정 가능
- set의 검색 시간은 상수, 그러니까 검색 대상이 set이 돼야 함
- dict 또한 검색 시간은 상수, 하지만 선언할 때 0으로 초기화 하는 등의 작업이 불가능, 접근은 dict[i] 와 같이 인덱스로 접근 가능
- dict에 존재하지 않는 인덱스에 접근하는 것은 불가능, 따라서 원소에 접근할 때 dict.get(i,0) 을 사용해서 i가 있으면 i, 아닌 경우는 0을 가져오도록 사용
- set 끼리는 |(합), &(교), -(차), ^(둘 중 한 곳에만 있는 것) 연산 가능
- ababc 에서 부분 문자열을 모두 구할 때 시작 부분을 하나씩 증가 시키면서 끝까지 잘라내면 됨. a ab aba abab ababc b ba bab babac c ...
- 기약분수 값을 구할 때 처음부터 기약분수로 만들고 통분을 하면 최종 결과에서 다시 약분해야 될 경우가 있을 수 있으므로 약분하지말고 통분 후 마지막에 최대공약수로 약분하기
- 12789번에서 간식을 받는 사람들의 배열은 필요 없음. 지금이 몇 번째 받는건지 변수 하나로 선언해서 풀면 메모리 절약 가능임.
- append() 가 뒤에 붙이니까 LIFO 형식이 되는거임. pop() 도 default는 맨 뒤 원소부터 처리함. 다만 pop(0) 과 같이 인덱스 설정 가능
- 원을 만든다 -> queue에서 특정 인덱스 앞(K-1)의 원소들을 popleft() 하고 다시 append() 해주면 원이 됨
